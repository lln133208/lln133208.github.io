---
layout: post
title: Datalab
categories: [CSAPP]
---

本实验共有13个Puzzle.

## BitXor

### 题目要求

```
 * bitXor - x^y using only ~ and & 
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &
 *   Max ops: 14
```

开始自己没有认真审题，除了规定的运算符之外，还是用了**+**，不过好在思路比较清晰，所以也把不符合要求的解决方法也记录下来。
### 解题思路
按位异或是将数以二进制形式表示，当在某位上数值不同时，则异或结果为1，否则结果为0。以8位二进制数为例，

```
X     0 0 0 0 1 0 0 1
Y     1 0 1 0 1 0 0 0
X^Y   1 0 1 0 0 0 0 1
```

我的想法是可以找出x和y中都为1的bit位，并将该bit位设置为1，其余bit位都设置为0。
`Ｘ＆Ｙ`

同样的，也通过同样的方法找到x和y中都为0的所有bit位，并将该bit位设置为1，其余bit位设置为0。
`(~X)&(~Y)`

将两者相加，其结果中为1的bit位表示在X和Y在该bit位上同为1或0，即在该位上两数相同。而结果中为0的bit位表示X和Y在该bit位上一个为1，另一个为0。
`(X&Y)+((~X)&(~Y))`

此时和题目的最终要求是相反的，只需要再按位取反即可。
`~((X&Y)+((~X)&(~Y)))`

很不幸的是，以上的方法虽然思路很清晰，但是超过了题目中对运算符类型的限制。因此需要想办法使用允许的运算符替换**+**

那换个思路，如果将`Ｘ＆Ｙ`按位取反，则结果中为0的bit位表示X和Y在该bit位上都为1。然后将`(~X)&(~Y)`也按位取反，则结果中为0的bit为表示X和Y在该bit位上都为0。
最终将两结果按位与，相当于一个交集，两者相同的部分被保留，其他都置为0。
`(~(X&Y))&(~((~X)&(~y)))`

## tmin 

### 题目要求

```
/* 
 * tmin - return minimum two's complement integer 
 *   Legal ops: ! ~ & ^ | + << >>
 *   Max ops: 4
 *   Rating: 1
 */
```

### 解题思路

有符号数的最小值就是符号位为1，其余位都为0的数。对0x01进行左移可以得到Tmin。

```
int tmin()
{
	return 1<<31;
}
```

## isTmax

### 题目要求

```
/*
 * isTmax - returns 1 if x is the maximum, two's complement number,
 *     and 0 otherwise 
 *   Legal ops: ! ~ & ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
```

### 解题思路

Tmax ： 符号位为0，其余位都为1。因此Tmax有个特点是，Tmax加1会导致溢出，结果变成Tmin。下图以8bit为例

```
|Tmax   | 0 1 1 1 1 1 1 1|
|1      | 0 0 0 0 0 0 0 1|
|———————|———————————————-|
|result | 1 0 0 0 0 0 0 0|
```
而 Tmax + Tmin + 1 = 0， 因此`(x+1+x+1)==0`可以用来判断x是否为Tmax。需要注意的是，还有一个特殊的例子也是满足这个等式的，那就是当x==0xff时，因此需要排除这个例外。如果排除这个例外呢，就需要仔细想想0xff和Tmax有啥不同的点。如果对0xff和Tmax都按位取反，会发现~0xff = 0, 而~Tmax != 0。 对于!!(~x)， 当x==0xff时，结果为0，而x==Tmax时，结果为1。

```
int isTmax(int x)
{
    int is_tmax_or_0xff = !(x+1+x+1);
    // is_tmax_or_0xff 用来判断该数是否为0xff或Tmax
    // (!!(~x))用来排除是否为0xff
    return is_tmax_or_0xff&(!!(~x));
}
```

## isAsciiDigit

### 题目要求

```
 * isAsciiDigit - return 1 if 0x30 <= x <= 0x39 (ASCII codes for characters '0' to '9')
 *   Example: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   Legal ops: ! ~ & ^ | + << >>
 *   Max ops: 15
```

### 解题思路

开始自己一直执着于进行bit位比较来判断大小，后来发现这条路走不通。参考了别人的思路，数学上比较大小可以使用减法

> 当结果为0或者正时，表示被减数大于等于减数；当结果为负时，表示被减数小于减数。

虽然题目要求中并没有允许使用**-**，但是减去一个数可以变化成加上这个数的相反数，而相反数又可以使用反码表示，即 X + Y = X + (-Y) = X + (~Y) + 1
有符号数的二进制表示中，最高位为符号位，因此我们可以通过该位来判断数的正负。

> `!(((x+(~y)+1)>>31)&0x01)` 将结果进行右移31位，相当于将符号位放置于最低有效位，这样不论是算数右移还是逻辑右移，在于0x01进行按位与操作后，都将只保留最低有效位。当结果等于0时，说明之前的符号位是0，进而得知X>=Y。

```c
int isAsciiDigit(int x)
{
	int great_than_0x30 = !(((x+(~0x30)+1)>>0x31)&0x01);
	int less_than_0x39 = !(((0x39+(~x)+1)>>31)&0x01);
	return great_than_0x30&less_than_0x39;
}
```
