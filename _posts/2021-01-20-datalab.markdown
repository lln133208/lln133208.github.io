---
layout: post
title: Datalab
categories: [CSAPP]
---

本实验共有13个Puzzle.

## BitXor

### 题目要求
仅使用**&**和**~**来实现按位异或**^**

开始自己没有认真审题，除了规定的运算符之外，还是用了**+**，不过好在思路比较清晰，所以也把不符合要求的解决方法也记录下来。
### 解题思路
按位异或是将数以二进制形式表示，当在某位上数值不同时，则异或结果为1，否则结果为0。以8位二进制数为例，

```
X     0 0 0 0 1 0 0 1
Y     1 0 1 0 1 0 0 0
X^Y   1 0 1 0 0 0 0 1
```

我的想法是可以找出x和y中都为1的bit位，并将该bit位设置为1，其余bit位都设置为0。
`Ｘ＆Ｙ`

同样的，也通过同样的方法找到x和y中都为0的所有bit位，并将该bit位设置为1，其余bit位设置为0。
`(~X)&(~Y)`

将两者相加，其结果中为1的bit位表示在X和Y在该bit位上同为1或0，即在该位上两数相同。而结果中为0的bit位表示X和Y在该bit位上一个为1，另一个为0。
`(X&Y)+((~X)&(~Y))`

此时和题目的最终要求是相反的，只需要再按位取反即可。
`~((X&Y)+((~X)&(~Y)))`

很不幸的是，以上的方法虽然思路很清晰，但是超过了题目中对运算符类型的限制。因此需要想办法使用允许的运算符替换**+**

那换个思路，如果将`Ｘ＆Ｙ`按位取反，则结果中为0的bit位表示X和Y在该bit位上都为1。然后将`(~X)&(~Y)`也按位取反，则结果中为0的bit为表示X和Y在该bit位上都为0。
最终将两结果按位与，相当于一个交集，两者相同的部分被保留，其他都置为0。
`(~(X&Y))&(~((~X)&(~y)))`
